"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_services_profileService_ts"],{

/***/ "(app-pages-browser)/../services/profileService.ts":
/*!*************************************!*\
  !*** ../services/profileService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createProfile: function() { return /* binding */ createProfile; },\n/* harmony export */   getCurrentUserProfile: function() { return /* binding */ getCurrentUserProfile; },\n/* harmony export */   getProfile: function() { return /* binding */ getProfile; },\n/* harmony export */   getProfileWithLanguages: function() { return /* binding */ getProfileWithLanguages; },\n/* harmony export */   getUserLanguages: function() { return /* binding */ getUserLanguages; },\n/* harmony export */   setOnlineStatus: function() { return /* binding */ setOnlineStatus; },\n/* harmony export */   updateCurrentUserProfile: function() { return /* binding */ updateCurrentUserProfile; },\n/* harmony export */   updateProfile: function() { return /* binding */ updateProfile; },\n/* harmony export */   updateUserLanguages: function() { return /* binding */ updateUserLanguages; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/errors */ \"(app-pages-browser)/../utils/errors.ts\");\n/**\n * Profile Service\n * Backend service for user profiles using new profiles table\n */ \n\n// ============================================================================\n// CREATE PROFILE\n// ============================================================================\n/**\n * Create user profile (inserts into profiles table)\n */ async function createProfile(input) {\n    const { userId, displayName, avatarUrl, bio, city, country, lat, lng } = input;\n    const insertData = {\n        id: userId,\n        display_name: displayName,\n        avatar_url: avatarUrl || null,\n        bio: bio || null,\n        city: city || null,\n        country: country || null,\n        lat: lat || null,\n        lng: lng || null,\n        is_online: false\n    };\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").insert(insertData).select().single();\n    if (error) {\n        // If profile already exists (from trigger), try to update it\n        if (error.code === \"23505\") {\n            return updateProfile(userId, {\n                displayName,\n                avatarUrl,\n                bio,\n                city,\n                country,\n                lat,\n                lng\n            });\n        }\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n    return data;\n}\n// ============================================================================\n// GET PROFILE\n// ============================================================================\n/**\n * Get current user's profile with languages\n * Reads from supabase.auth.getUser() and fetches profile + languages\n * Returns clean structured object with grouped languages\n */ async function getCurrentUserProfile() {\n    // Get current authenticated user\n    const { data: { user }, error: authError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (authError || !user) {\n        console.log(\"getCurrentUserProfile - No authenticated user:\", authError === null || authError === void 0 ? void 0 : authError.message);\n        return null;\n    }\n    console.log(\"getCurrentUserProfile - Fetching profile for user:\", user.id);\n    // Fetch profile from profiles table\n    const { data: profile, error: profileError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", user.id).single();\n    if (profileError) {\n        if (profileError.code === \"PGRST116\") {\n            // Profile doesn't exist yet\n            console.log(\"getCurrentUserProfile - Profile not found for user:\", user.id);\n            return null;\n        }\n        console.error(\"getCurrentUserProfile - Error fetching profile:\", profileError);\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(profileError);\n    }\n    console.log(\"getCurrentUserProfile - Profile found:\", profile === null || profile === void 0 ? void 0 : profile.display_name);\n    // Fetch languages from user_languages table\n    const { data: languages, error: langError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"user_languages\").select(\"*\").eq(\"user_id\", user.id);\n    if (langError) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(langError);\n    }\n    // Group languages by role\n    const learningLanguages = (languages || []).filter((lang)=>lang.role === \"learning\").map((lang)=>({\n            language: lang.language,\n            level: lang.level\n        }));\n    const teachingLanguages = (languages || []).filter((lang)=>lang.role === \"teaching\").map((lang)=>({\n            language: lang.language,\n            level: lang.level\n        }));\n    // Return structured object\n    // Note: interests is not in profiles table yet, returning null for now\n    const result = {\n        id: profile.id,\n        displayName: profile.display_name,\n        avatarUrl: profile.avatar_url,\n        bio: profile.bio,\n        city: profile.city,\n        country: profile.country,\n        interests: null,\n        languages: {\n            learning: learningLanguages,\n            teaching: teachingLanguages\n        }\n    };\n    console.log(\"getCurrentUserProfile - Returning profile:\", {\n        displayName: result.displayName,\n        hasLanguages: result.languages.learning.length + result.languages.teaching.length\n    });\n    return result;\n}\n/**\n * Get user profile by ID\n */ async function getProfile(userId) {\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", userId).single();\n    if (error) {\n        if (error.code === \"PGRST116\") {\n            return null;\n        }\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n    return data;\n}\n/**\n * Get user profile with languages\n */ async function getProfileWithLanguages(userId) {\n    const { data: profile, error: profileError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", userId).single();\n    if (profileError) {\n        if (profileError.code === \"PGRST116\") {\n            return null;\n        }\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(profileError);\n    }\n    const { data: languages, error: langError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"user_languages\").select(\"*\").eq(\"user_id\", userId);\n    if (langError) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(langError);\n    }\n    return {\n        ...profile,\n        languages: languages || []\n    };\n}\n// ============================================================================\n// UPDATE PROFILE\n// ============================================================================\n/**\n * Update current user's profile\n * Automatically gets current user from session\n */ async function updateCurrentUserProfile(input) {\n    // Get current user\n    const { data: { user } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (!user) {\n        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_1__.ValidationError(\"User must be authenticated to update profile.\");\n    }\n    return updateProfile(user.id, input);\n}\n/**\n * Update user profile\n */ async function updateProfile(userId, input) {\n    const updateData = {};\n    if (input.displayName !== undefined) updateData.display_name = input.displayName;\n    if (input.avatarUrl !== undefined) updateData.avatar_url = input.avatarUrl;\n    if (input.bio !== undefined) updateData.bio = input.bio;\n    if (input.city !== undefined) updateData.city = input.city;\n    if (input.country !== undefined) updateData.country = input.country;\n    if (input.lat !== undefined) updateData.lat = input.lat;\n    if (input.lng !== undefined) updateData.lng = input.lng;\n    if (input.isOnline !== undefined) {\n        updateData.is_online = input.isOnline;\n        updateData.last_active_at = new Date().toISOString();\n    }\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").update(updateData).eq(\"id\", userId).select().single();\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n    return data;\n}\n// ============================================================================\n// LANGUAGES\n// ============================================================================\n/**\n * Get user's languages\n */ async function getUserLanguages(userId) {\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"user_languages\").select(\"*\").eq(\"user_id\", userId).order(\"role\", {\n        ascending: true\n    }).order(\"created_at\", {\n        ascending: true\n    });\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n    return data || [];\n}\n/**\n * Update user languages (replaces all existing languages)\n */ async function updateUserLanguages(userId, input) {\n    // Delete existing languages\n    const { error: deleteError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"user_languages\").delete().eq(\"user_id\", userId);\n    if (deleteError) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(deleteError);\n    }\n    // Insert new languages\n    if (input.languages.length === 0) {\n        return [];\n    }\n    const languageInserts = input.languages.map((lang)=>({\n            user_id: userId,\n            language: lang.language,\n            level: lang.level,\n            role: lang.role\n        }));\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"user_languages\").insert(languageInserts).select();\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n    return data || [];\n}\n// ============================================================================\n// ONLINE STATUS\n// ============================================================================\n/**\n * Update user's online status\n */ async function setOnlineStatus(userId, isOnline) {\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").update({\n        is_online: isOnline,\n        last_active_at: new Date().toISOString()\n    }).eq(\"id\", userId);\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_1__.parseSupabaseError)(error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zZXJ2aWNlcy9wcm9maWxlU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUV5QztBQVVsQjtBQXVEeEIsK0VBQStFO0FBQy9FLGlCQUFpQjtBQUNqQiwrRUFBK0U7QUFFL0U7O0NBRUMsR0FDTSxlQUFlRyxjQUFjQyxLQUF5QjtJQUMzRCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFLEdBQUdSO0lBRXpFLE1BQU1TLGFBQTRCO1FBQ2hDQyxJQUFJVDtRQUNKVSxjQUFjVDtRQUNkVSxZQUFZVCxhQUFhO1FBQ3pCQyxLQUFLQSxPQUFPO1FBQ1pDLE1BQU1BLFFBQVE7UUFDZEMsU0FBU0EsV0FBVztRQUNwQkMsS0FBS0EsT0FBTztRQUNaQyxLQUFLQSxPQUFPO1FBQ1pLLFdBQVc7SUFDYjtJQUVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNbkIsbURBQVFBLENBQ25Db0IsSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQ1IsWUFDUFMsTUFBTSxHQUNOQyxNQUFNO0lBRVQsSUFBSUosT0FBTztRQUNULDZEQUE2RDtRQUM3RCxJQUFJQSxNQUFNSyxJQUFJLEtBQUssU0FBUztZQUMxQixPQUFPQyxjQUFjcEIsUUFBUTtnQkFDM0JDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBLE1BQU1WLGlFQUFrQkEsQ0FBQ2lCO0lBQzNCO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLCtFQUErRTtBQUMvRSxjQUFjO0FBQ2QsK0VBQStFO0FBRS9FOzs7O0NBSUMsR0FDTSxlQUFlUTtJQUNwQixpQ0FBaUM7SUFDakMsTUFBTSxFQUFFUixNQUFNLEVBQUVTLElBQUksRUFBRSxFQUFFUixPQUFPUyxT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R0FDTSxlQUFlcUQsZ0JBQWdCbEUsTUFBYyxFQUFFcUQsUUFBaUI7SUFDckUsTUFBTSxFQUFFdkMsS0FBSyxFQUFFLEdBQUcsTUFBTW5CLG1EQUFRQSxDQUM3Qm9CLElBQUksQ0FBQyxZQUNMMEMsTUFBTSxDQUFDO1FBQ043QyxXQUFXeUM7UUFDWEMsZ0JBQWdCLElBQUlDLE9BQU9DLFdBQVc7SUFDeEMsR0FDQ3pCLEVBQUUsQ0FBQyxNQUFNL0I7SUFFWixJQUFJYyxPQUFPO1FBQ1QsTUFBTWpCLGlFQUFrQkEsQ0FBQ2lCO0lBQzNCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NlcnZpY2VzL3Byb2ZpbGVTZXJ2aWNlLnRzPzIwODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9maWxlIFNlcnZpY2VcbiAqIEJhY2tlbmQgc2VydmljZSBmb3IgdXNlciBwcm9maWxlcyB1c2luZyBuZXcgcHJvZmlsZXMgdGFibGVcbiAqL1xuXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcbmltcG9ydCB7XG4gIHByb2ZpbGVVcGRhdGVTY2hlbWEsXG4gIHR5cGUgUHJvZmlsZVVwZGF0ZUlucHV0LFxufSBmcm9tICdAL3V0aWxzL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHtcbiAgRGF0YWJhc2VFcnJvcixcbiAgUmVjb3JkTm90Rm91bmRFcnJvcixcbiAgVmFsaWRhdGlvbkVycm9yLFxuICBwYXJzZVN1cGFiYXNlRXJyb3IsXG59IGZyb20gJ0AvdXRpbHMvZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgUHJvZmlsZSwgUHJvZmlsZUluc2VydCwgUHJvZmlsZVVwZGF0ZSwgVXNlckxhbmd1YWdlLCBVc2VyTGFuZ3VhZ2VJbnNlcnQgfSBmcm9tICdAL3R5cGVzL2RhdGFiYXNlJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVFlQRVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVQcm9maWxlSW5wdXQge1xuICB1c2VySWQ6IHN0cmluZztcbiAgZGlzcGxheU5hbWU6IHN0cmluZztcbiAgYXZhdGFyVXJsPzogc3RyaW5nO1xuICBiaW8/OiBzdHJpbmc7XG4gIGNpdHk/OiBzdHJpbmc7XG4gIGNvdW50cnk/OiBzdHJpbmc7XG4gIGxhdD86IG51bWJlcjtcbiAgbG5nPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVByb2ZpbGVJbnB1dCB7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBhdmF0YXJVcmw/OiBzdHJpbmcgfCBudWxsO1xuICBiaW8/OiBzdHJpbmc7XG4gIGNpdHk/OiBzdHJpbmc7XG4gIGNvdW50cnk/OiBzdHJpbmc7XG4gIGxhdD86IG51bWJlcjtcbiAgbG5nPzogbnVtYmVyO1xuICBpc09ubGluZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlTGFuZ3VhZ2VzSW5wdXQge1xuICBsYW5ndWFnZXM6IEFycmF5PHtcbiAgICBsYW5ndWFnZTogc3RyaW5nO1xuICAgIGxldmVsOiAnbmF0aXZlJyB8ICdhZHZhbmNlZCcgfCAnaW50ZXJtZWRpYXRlJyB8ICdiZWdpbm5lcicgfCBudWxsO1xuICAgIHJvbGU6ICd0ZWFjaGluZycgfCAnbGVhcm5pbmcnO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlV2l0aExhbmd1YWdlcyBleHRlbmRzIFByb2ZpbGUge1xuICBsYW5ndWFnZXM6IFVzZXJMYW5ndWFnZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnJlbnRVc2VyUHJvZmlsZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmc7XG4gIGF2YXRhclVybDogc3RyaW5nIHwgbnVsbDtcbiAgYmlvOiBzdHJpbmcgfCBudWxsO1xuICBjaXR5OiBzdHJpbmcgfCBudWxsO1xuICBjb3VudHJ5OiBzdHJpbmcgfCBudWxsO1xuICBpbnRlcmVzdHM6IHN0cmluZ1tdIHwgbnVsbDtcbiAgbGFuZ3VhZ2VzOiB7XG4gICAgbGVhcm5pbmc6IEFycmF5PHsgbGFuZ3VhZ2U6IHN0cmluZzsgbGV2ZWw6IHN0cmluZyB8IG51bGwgfT47XG4gICAgdGVhY2hpbmc6IEFycmF5PHsgbGFuZ3VhZ2U6IHN0cmluZzsgbGV2ZWw6IHN0cmluZyB8IG51bGwgfT47XG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENSRUFURSBQUk9GSUxFXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ3JlYXRlIHVzZXIgcHJvZmlsZSAoaW5zZXJ0cyBpbnRvIHByb2ZpbGVzIHRhYmxlKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHJvZmlsZShpbnB1dDogQ3JlYXRlUHJvZmlsZUlucHV0KTogUHJvbWlzZTxQcm9maWxlPiB7XG4gIGNvbnN0IHsgdXNlcklkLCBkaXNwbGF5TmFtZSwgYXZhdGFyVXJsLCBiaW8sIGNpdHksIGNvdW50cnksIGxhdCwgbG5nIH0gPSBpbnB1dDtcblxuICBjb25zdCBpbnNlcnREYXRhOiBQcm9maWxlSW5zZXJ0ID0ge1xuICAgIGlkOiB1c2VySWQsXG4gICAgZGlzcGxheV9uYW1lOiBkaXNwbGF5TmFtZSxcbiAgICBhdmF0YXJfdXJsOiBhdmF0YXJVcmwgfHwgbnVsbCxcbiAgICBiaW86IGJpbyB8fCBudWxsLFxuICAgIGNpdHk6IGNpdHkgfHwgbnVsbCxcbiAgICBjb3VudHJ5OiBjb3VudHJ5IHx8IG51bGwsXG4gICAgbGF0OiBsYXQgfHwgbnVsbCxcbiAgICBsbmc6IGxuZyB8fCBudWxsLFxuICAgIGlzX29ubGluZTogZmFsc2UsXG4gIH07XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgIC5pbnNlcnQoaW5zZXJ0RGF0YSlcbiAgICAuc2VsZWN0KClcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgLy8gSWYgcHJvZmlsZSBhbHJlYWR5IGV4aXN0cyAoZnJvbSB0cmlnZ2VyKSwgdHJ5IHRvIHVwZGF0ZSBpdFxuICAgIGlmIChlcnJvci5jb2RlID09PSAnMjM1MDUnKSB7IC8vIFVuaXF1ZSB2aW9sYXRpb25cbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlKHVzZXJJZCwge1xuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgYXZhdGFyVXJsLFxuICAgICAgICBiaW8sXG4gICAgICAgIGNpdHksXG4gICAgICAgIGNvdW50cnksXG4gICAgICAgIGxhdCxcbiAgICAgICAgbG5nLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IHBhcnNlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gR0VUIFBST0ZJTEVcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgY3VycmVudCB1c2VyJ3MgcHJvZmlsZSB3aXRoIGxhbmd1YWdlc1xuICogUmVhZHMgZnJvbSBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKSBhbmQgZmV0Y2hlcyBwcm9maWxlICsgbGFuZ3VhZ2VzXG4gKiBSZXR1cm5zIGNsZWFuIHN0cnVjdHVyZWQgb2JqZWN0IHdpdGggZ3JvdXBlZCBsYW5ndWFnZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRVc2VyUHJvZmlsZSgpOiBQcm9taXNlPEN1cnJlbnRVc2VyUHJvZmlsZSB8IG51bGw+IHtcbiAgLy8gR2V0IGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyXG4gIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICBcbiAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgIGNvbnNvbGUubG9nKCdnZXRDdXJyZW50VXNlclByb2ZpbGUgLSBObyBhdXRoZW50aWNhdGVkIHVzZXI6JywgYXV0aEVycm9yPy5tZXNzYWdlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdnZXRDdXJyZW50VXNlclByb2ZpbGUgLSBGZXRjaGluZyBwcm9maWxlIGZvciB1c2VyOicsIHVzZXIuaWQpO1xuXG4gIC8vIEZldGNoIHByb2ZpbGUgZnJvbSBwcm9maWxlcyB0YWJsZVxuICBjb25zdCB7IGRhdGE6IHByb2ZpbGUsIGVycm9yOiBwcm9maWxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKHByb2ZpbGVFcnJvcikge1xuICAgIGlmIChwcm9maWxlRXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgLy8gUHJvZmlsZSBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgY29uc29sZS5sb2coJ2dldEN1cnJlbnRVc2VyUHJvZmlsZSAtIFByb2ZpbGUgbm90IGZvdW5kIGZvciB1c2VyOicsIHVzZXIuaWQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dldEN1cnJlbnRVc2VyUHJvZmlsZSAtIEVycm9yIGZldGNoaW5nIHByb2ZpbGU6JywgcHJvZmlsZUVycm9yKTtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IocHJvZmlsZUVycm9yKTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdnZXRDdXJyZW50VXNlclByb2ZpbGUgLSBQcm9maWxlIGZvdW5kOicsIHByb2ZpbGU/LmRpc3BsYXlfbmFtZSk7XG5cbiAgLy8gRmV0Y2ggbGFuZ3VhZ2VzIGZyb20gdXNlcl9sYW5ndWFnZXMgdGFibGVcbiAgY29uc3QgeyBkYXRhOiBsYW5ndWFnZXMsIGVycm9yOiBsYW5nRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3VzZXJfbGFuZ3VhZ2VzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcblxuICBpZiAobGFuZ0Vycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGxhbmdFcnJvcik7XG4gIH1cblxuICAvLyBHcm91cCBsYW5ndWFnZXMgYnkgcm9sZVxuICBjb25zdCBsZWFybmluZ0xhbmd1YWdlcyA9IChsYW5ndWFnZXMgfHwgW10pXG4gICAgLmZpbHRlcigobGFuZzogVXNlckxhbmd1YWdlKSA9PiBsYW5nLnJvbGUgPT09ICdsZWFybmluZycpXG4gICAgLm1hcCgobGFuZzogVXNlckxhbmd1YWdlKSA9PiAoe1xuICAgICAgbGFuZ3VhZ2U6IGxhbmcubGFuZ3VhZ2UsXG4gICAgICBsZXZlbDogbGFuZy5sZXZlbCxcbiAgICB9KSk7XG5cbiAgY29uc3QgdGVhY2hpbmdMYW5ndWFnZXMgPSAobGFuZ3VhZ2VzIHx8IFtdKVxuICAgIC5maWx0ZXIoKGxhbmc6IFVzZXJMYW5ndWFnZSkgPT4gbGFuZy5yb2xlID09PSAndGVhY2hpbmcnKVxuICAgIC5tYXAoKGxhbmc6IFVzZXJMYW5ndWFnZSkgPT4gKHtcbiAgICAgIGxhbmd1YWdlOiBsYW5nLmxhbmd1YWdlLFxuICAgICAgbGV2ZWw6IGxhbmcubGV2ZWwsXG4gICAgfSkpO1xuXG4gIC8vIFJldHVybiBzdHJ1Y3R1cmVkIG9iamVjdFxuICAvLyBOb3RlOiBpbnRlcmVzdHMgaXMgbm90IGluIHByb2ZpbGVzIHRhYmxlIHlldCwgcmV0dXJuaW5nIG51bGwgZm9yIG5vd1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQ6IHByb2ZpbGUuaWQsXG4gICAgZGlzcGxheU5hbWU6IHByb2ZpbGUuZGlzcGxheV9uYW1lLFxuICAgIGF2YXRhclVybDogcHJvZmlsZS5hdmF0YXJfdXJsLFxuICAgIGJpbzogcHJvZmlsZS5iaW8sXG4gICAgY2l0eTogcHJvZmlsZS5jaXR5LFxuICAgIGNvdW50cnk6IHByb2ZpbGUuY291bnRyeSxcbiAgICBpbnRlcmVzdHM6IG51bGwsIC8vIFRPRE86IEFkZCBpbnRlcmVzdHMgY29sdW1uIHRvIHByb2ZpbGVzIHRhYmxlXG4gICAgbGFuZ3VhZ2VzOiB7XG4gICAgICBsZWFybmluZzogbGVhcm5pbmdMYW5ndWFnZXMsXG4gICAgICB0ZWFjaGluZzogdGVhY2hpbmdMYW5ndWFnZXMsXG4gICAgfSxcbiAgfTtcblxuICBjb25zb2xlLmxvZygnZ2V0Q3VycmVudFVzZXJQcm9maWxlIC0gUmV0dXJuaW5nIHByb2ZpbGU6Jywge1xuICAgIGRpc3BsYXlOYW1lOiByZXN1bHQuZGlzcGxheU5hbWUsXG4gICAgaGFzTGFuZ3VhZ2VzOiByZXN1bHQubGFuZ3VhZ2VzLmxlYXJuaW5nLmxlbmd0aCArIHJlc3VsdC5sYW5ndWFnZXMudGVhY2hpbmcubGVuZ3RoLFxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB1c2VyIHByb2ZpbGUgYnkgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2ZpbGUodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFByb2ZpbGUgfCBudWxsPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRocm93IHBhcnNlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdXNlciBwcm9maWxlIHdpdGggbGFuZ3VhZ2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9maWxlV2l0aExhbmd1YWdlcyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvZmlsZVdpdGhMYW5ndWFnZXMgfCBudWxsPiB7XG4gIGNvbnN0IHsgZGF0YTogcHJvZmlsZSwgZXJyb3I6IHByb2ZpbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCB1c2VySWQpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChwcm9maWxlRXJyb3IpIHtcbiAgICBpZiAocHJvZmlsZUVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IocHJvZmlsZUVycm9yKTtcbiAgfVxuXG4gIGNvbnN0IHsgZGF0YTogbGFuZ3VhZ2VzLCBlcnJvcjogbGFuZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCd1c2VyX2xhbmd1YWdlcycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcblxuICBpZiAobGFuZ0Vycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGxhbmdFcnJvcik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnByb2ZpbGUsXG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMgfHwgW10sXG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFVQREFURSBQUk9GSUxFXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVXBkYXRlIGN1cnJlbnQgdXNlcidzIHByb2ZpbGVcbiAqIEF1dG9tYXRpY2FsbHkgZ2V0cyBjdXJyZW50IHVzZXIgZnJvbSBzZXNzaW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlclByb2ZpbGUoXG4gIGlucHV0OiBVcGRhdGVQcm9maWxlSW5wdXRcbik6IFByb21pc2U8UHJvZmlsZT4ge1xuICAvLyBHZXQgY3VycmVudCB1c2VyXG4gIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICBpZiAoIXVzZXIpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byB1cGRhdGUgcHJvZmlsZS4nKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQcm9maWxlKHVzZXIuaWQsIGlucHV0KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdXNlciBwcm9maWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9maWxlKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgaW5wdXQ6IFVwZGF0ZVByb2ZpbGVJbnB1dFxuKTogUHJvbWlzZTxQcm9maWxlPiB7XG4gIGNvbnN0IHVwZGF0ZURhdGE6IFByb2ZpbGVVcGRhdGUgPSB7fTtcblxuICBpZiAoaW5wdXQuZGlzcGxheU5hbWUgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5kaXNwbGF5X25hbWUgPSBpbnB1dC5kaXNwbGF5TmFtZTtcbiAgaWYgKGlucHV0LmF2YXRhclVybCAhPT0gdW5kZWZpbmVkKSB1cGRhdGVEYXRhLmF2YXRhcl91cmwgPSBpbnB1dC5hdmF0YXJVcmw7XG4gIGlmIChpbnB1dC5iaW8gIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5iaW8gPSBpbnB1dC5iaW87XG4gIGlmIChpbnB1dC5jaXR5ICE9PSB1bmRlZmluZWQpIHVwZGF0ZURhdGEuY2l0eSA9IGlucHV0LmNpdHk7XG4gIGlmIChpbnB1dC5jb3VudHJ5ICE9PSB1bmRlZmluZWQpIHVwZGF0ZURhdGEuY291bnRyeSA9IGlucHV0LmNvdW50cnk7XG4gIGlmIChpbnB1dC5sYXQgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5sYXQgPSBpbnB1dC5sYXQ7XG4gIGlmIChpbnB1dC5sbmcgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5sbmcgPSBpbnB1dC5sbmc7XG4gIGlmIChpbnB1dC5pc09ubGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXBkYXRlRGF0YS5pc19vbmxpbmUgPSBpbnB1dC5pc09ubGluZTtcbiAgICB1cGRhdGVEYXRhLmxhc3RfYWN0aXZlX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICB9XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgIC5zZWxlY3QoKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExBTkdVQUdFU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCB1c2VyJ3MgbGFuZ3VhZ2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyTGFuZ3VhZ2VzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyTGFuZ3VhZ2VbXT4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCd1c2VyX2xhbmd1YWdlcycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgIC5vcmRlcigncm9sZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG4gICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB1c2VyIGxhbmd1YWdlcyAocmVwbGFjZXMgYWxsIGV4aXN0aW5nIGxhbmd1YWdlcylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVVzZXJMYW5ndWFnZXMoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBpbnB1dDogVXBkYXRlTGFuZ3VhZ2VzSW5wdXRcbik6IFByb21pc2U8VXNlckxhbmd1YWdlW10+IHtcbiAgLy8gRGVsZXRlIGV4aXN0aW5nIGxhbmd1YWdlc1xuICBjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgndXNlcl9sYW5ndWFnZXMnKVxuICAgIC5kZWxldGUoKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG5cbiAgaWYgKGRlbGV0ZUVycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGRlbGV0ZUVycm9yKTtcbiAgfVxuXG4gIC8vIEluc2VydCBuZXcgbGFuZ3VhZ2VzXG4gIGlmIChpbnB1dC5sYW5ndWFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGFuZ3VhZ2VJbnNlcnRzOiBVc2VyTGFuZ3VhZ2VJbnNlcnRbXSA9IGlucHV0Lmxhbmd1YWdlcy5tYXAoKGxhbmcpID0+ICh7XG4gICAgdXNlcl9pZDogdXNlcklkLFxuICAgIGxhbmd1YWdlOiBsYW5nLmxhbmd1YWdlLFxuICAgIGxldmVsOiBsYW5nLmxldmVsLFxuICAgIHJvbGU6IGxhbmcucm9sZSxcbiAgfSkpO1xuXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3VzZXJfbGFuZ3VhZ2VzJylcbiAgICAuaW5zZXJ0KGxhbmd1YWdlSW5zZXJ0cylcbiAgICAuc2VsZWN0KCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPTkxJTkUgU1RBVFVTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVXBkYXRlIHVzZXIncyBvbmxpbmUgc3RhdHVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRPbmxpbmVTdGF0dXModXNlcklkOiBzdHJpbmcsIGlzT25saW5lOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAudXBkYXRlKHtcbiAgICAgIGlzX29ubGluZTogaXNPbmxpbmUsXG4gICAgICBsYXN0X2FjdGl2ZV9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gICAgLmVxKCdpZCcsIHVzZXJJZCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJWYWxpZGF0aW9uRXJyb3IiLCJwYXJzZVN1cGFiYXNlRXJyb3IiLCJjcmVhdGVQcm9maWxlIiwiaW5wdXQiLCJ1c2VySWQiLCJkaXNwbGF5TmFtZSIsImF2YXRhclVybCIsImJpbyIsImNpdHkiLCJjb3VudHJ5IiwibGF0IiwibG5nIiwiaW5zZXJ0RGF0YSIsImlkIiwiZGlzcGxheV9uYW1lIiwiYXZhdGFyX3VybCIsImlzX29ubGluZSIsImRhdGEiLCJlcnJvciIsImZyb20iLCJpbnNlcnQiLCJzZWxlY3QiLCJzaW5nbGUiLCJjb2RlIiwidXBkYXRlUHJvZmlsZSIsImdldEN1cnJlbnRVc2VyUHJvZmlsZSIsInVzZXIiLCJhdXRoRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwicHJvZmlsZSIsInByb2ZpbGVFcnJvciIsImVxIiwibGFuZ3VhZ2VzIiwibGFuZ0Vycm9yIiwibGVhcm5pbmdMYW5ndWFnZXMiLCJmaWx0ZXIiLCJsYW5nIiwicm9sZSIsIm1hcCIsImxhbmd1YWdlIiwibGV2ZWwiLCJ0ZWFjaGluZ0xhbmd1YWdlcyIsInJlc3VsdCIsImludGVyZXN0cyIsImxlYXJuaW5nIiwidGVhY2hpbmciLCJoYXNMYW5ndWFnZXMiLCJsZW5ndGgiLCJnZXRQcm9maWxlIiwiZ2V0UHJvZmlsZVdpdGhMYW5ndWFnZXMiLCJ1cGRhdGVDdXJyZW50VXNlclByb2ZpbGUiLCJ1cGRhdGVEYXRhIiwidW5kZWZpbmVkIiwiaXNPbmxpbmUiLCJsYXN0X2FjdGl2ZV9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZSIsImdldFVzZXJMYW5ndWFnZXMiLCJvcmRlciIsImFzY2VuZGluZyIsInVwZGF0ZVVzZXJMYW5ndWFnZXMiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsImxhbmd1YWdlSW5zZXJ0cyIsInVzZXJfaWQiLCJzZXRPbmxpbmVTdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../services/profileService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../utils/errors.ts":
/*!**************************!*\
  !*** ../utils/errors.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppError: function() { return /* binding */ AppError; },\n/* harmony export */   AuthError: function() { return /* binding */ AuthError; },\n/* harmony export */   DatabaseError: function() { return /* binding */ DatabaseError; },\n/* harmony export */   DuplicateRecordError: function() { return /* binding */ DuplicateRecordError; },\n/* harmony export */   EmailNotVerifiedError: function() { return /* binding */ EmailNotVerifiedError; },\n/* harmony export */   FileTooLargeError: function() { return /* binding */ FileTooLargeError; },\n/* harmony export */   FileUploadError: function() { return /* binding */ FileUploadError; },\n/* harmony export */   InvalidCredentialsError: function() { return /* binding */ InvalidCredentialsError; },\n/* harmony export */   InvalidFileTypeError: function() { return /* binding */ InvalidFileTypeError; },\n/* harmony export */   NetworkError: function() { return /* binding */ NetworkError; },\n/* harmony export */   RecordNotFoundError: function() { return /* binding */ RecordNotFoundError; },\n/* harmony export */   SessionExpiredError: function() { return /* binding */ SessionExpiredError; },\n/* harmony export */   StorageError: function() { return /* binding */ StorageError; },\n/* harmony export */   UserAlreadyExistsError: function() { return /* binding */ UserAlreadyExistsError; },\n/* harmony export */   UserNotFoundError: function() { return /* binding */ UserNotFoundError; },\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   getUserFriendlyMessage: function() { return /* binding */ getUserFriendlyMessage; },\n/* harmony export */   isAppError: function() { return /* binding */ isAppError; },\n/* harmony export */   parseSupabaseError: function() { return /* binding */ parseSupabaseError; }\n/* harmony export */ });\n/**\n * Custom Error Classes\n * Production-ready error handling for the app\n */ /**\n * Base application error\n */ class AppError extends Error {\n    constructor(message, code = \"APP_ERROR\", statusCode = 500, isOperational = true){\n        super(message);\n        this.code = code;\n        this.statusCode = statusCode;\n        this.isOperational = isOperational;\n        Object.setPrototypeOf(this, AppError.prototype);\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\n * Authentication errors\n */ class AuthError extends AppError {\n    constructor(message, code = \"AUTH_ERROR\"){\n        super(message, code, 401);\n    }\n}\nclass InvalidCredentialsError extends AuthError {\n    constructor(message = \"Invalid email or password\"){\n        super(message, \"INVALID_CREDENTIALS\");\n    }\n}\nclass UserAlreadyExistsError extends AuthError {\n    constructor(message = \"A user with this email already exists. Please sign in instead.\"){\n        super(message, \"USER_ALREADY_EXISTS\");\n    }\n}\nclass UserNotFoundError extends AuthError {\n    constructor(message = \"User not found\"){\n        super(message, \"USER_NOT_FOUND\");\n    }\n}\nclass SessionExpiredError extends AuthError {\n    constructor(message = \"Session has expired. Please sign in again.\"){\n        super(message, \"SESSION_EXPIRED\");\n    }\n}\nclass EmailNotVerifiedError extends AuthError {\n    constructor(message = \"Please verify your email before continuing\"){\n        super(message, \"EMAIL_NOT_VERIFIED\");\n    }\n}\n/**\n * Validation errors\n */ class ValidationError extends AppError {\n    constructor(message, errors = {}){\n        super(message, \"VALIDATION_ERROR\", 400);\n        this.errors = errors;\n    }\n}\n/**\n * Database errors\n */ class DatabaseError extends AppError {\n    constructor(message = \"Database operation failed\"){\n        super(message, \"DATABASE_ERROR\", 500);\n    }\n}\nclass RecordNotFoundError extends AppError {\n    constructor(message = \"Record not found\"){\n        super(message, \"RECORD_NOT_FOUND\", 404);\n    }\n}\nclass DuplicateRecordError extends AppError {\n    constructor(message = \"Record already exists\"){\n        super(message, \"DUPLICATE_RECORD\", 409);\n    }\n}\n/**\n * Storage errors\n */ class StorageError extends AppError {\n    constructor(message = \"Storage operation failed\"){\n        super(message, \"STORAGE_ERROR\", 500);\n    }\n}\nclass FileUploadError extends StorageError {\n    constructor(message = \"Failed to upload file\"){\n        super(message);\n        this.code = \"FILE_UPLOAD_ERROR\";\n    }\n}\nclass FileTooLargeError extends StorageError {\n    constructor(maxSizeMB = 5){\n        super(\"File size exceeds maximum allowed size of \".concat(maxSizeMB, \"MB\"));\n        this.code = \"FILE_TOO_LARGE\";\n    }\n}\nclass InvalidFileTypeError extends StorageError {\n    constructor(allowedTypes = [\n        \"image/jpeg\",\n        \"image/png\",\n        \"image/webp\"\n    ]){\n        super(\"Invalid file type. Allowed types: \".concat(allowedTypes.join(\", \")));\n        this.code = \"INVALID_FILE_TYPE\";\n    }\n}\n/**\n * Network errors\n */ class NetworkError extends AppError {\n    constructor(message = \"Network request failed\"){\n        super(message, \"NETWORK_ERROR\", 503);\n    }\n}\n/**\n * Parse Supabase errors into custom errors\n */ function parseSupabaseError(error) {\n    const message = (error === null || error === void 0 ? void 0 : error.message) || \"An unexpected error occurred\";\n    const code = (error === null || error === void 0 ? void 0 : error.code) || \"\";\n    // Auth errors\n    if (message.includes(\"User already registered\") || message.includes(\"already exists\") || message.includes(\"already registered\") || code === \"user_already_exists\" || code === \"23505\" // PostgreSQL unique constraint violation\n    ) {\n        return new UserAlreadyExistsError();\n    }\n    if (message.includes(\"Invalid login credentials\") || code === \"invalid_credentials\") {\n        return new InvalidCredentialsError();\n    }\n    if (message.includes(\"Email not confirmed\")) {\n        return new EmailNotVerifiedError();\n    }\n    if (message.includes(\"JWT\") || message.includes(\"token\") || code === \"session_expired\") {\n        return new SessionExpiredError();\n    }\n    if (message.includes(\"User not found\")) {\n        return new UserNotFoundError();\n    }\n    // Database errors\n    if (code === \"23505\" || message.includes(\"duplicate key\")) {\n        return new DuplicateRecordError();\n    }\n    if (code === \"PGRST116\" || message.includes(\"not found\")) {\n        return new RecordNotFoundError();\n    }\n    // Default to generic app error\n    return new AppError(message, code || \"UNKNOWN_ERROR\");\n}\n/**\n * Type guard to check if error is an AppError\n */ function isAppError(error) {\n    return error instanceof AppError;\n}\n/**\n * Get user-friendly error message\n */ function getUserFriendlyMessage(error) {\n    if (isAppError(error)) {\n        return error.message;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return \"An unexpected error occurred. Please try again.\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi91dGlscy9lcnJvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVEOztDQUVDLEdBQ00sTUFBTUEsaUJBQWlCQztJQUs1QkMsWUFDRUMsT0FBZSxFQUNmQyxPQUFlLFdBQVcsRUFDMUJDLGFBQXFCLEdBQUcsRUFDeEJDLGdCQUF5QixJQUFJLENBQzdCO1FBQ0EsS0FBSyxDQUFDSDtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGFBQWEsR0FBR0E7UUFDckJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVSLFNBQVNTLFNBQVM7UUFDOUNSLE1BQU1TLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNSLFdBQVc7SUFDaEQ7QUFDRjtBQUVBOztDQUVDLEdBQ00sTUFBTVMsa0JBQWtCWDtJQUM3QkUsWUFBWUMsT0FBZSxFQUFFQyxPQUFlLFlBQVksQ0FBRTtRQUN4RCxLQUFLLENBQUNELFNBQVNDLE1BQU07SUFDdkI7QUFDRjtBQUVPLE1BQU1RLGdDQUFnQ0Q7SUFDM0NULFlBQVlDLFVBQWtCLDJCQUEyQixDQUFFO1FBQ3pELEtBQUssQ0FBQ0EsU0FBUztJQUNqQjtBQUNGO0FBRU8sTUFBTVUsK0JBQStCRjtJQUMxQ1QsWUFBWUMsVUFBa0IsZ0VBQWdFLENBQUU7UUFDOUYsS0FBSyxDQUFDQSxTQUFTO0lBQ2pCO0FBQ0Y7QUFFTyxNQUFNVywwQkFBMEJIO0lBQ3JDVCxZQUFZQyxVQUFrQixnQkFBZ0IsQ0FBRTtRQUM5QyxLQUFLLENBQUNBLFNBQVM7SUFDakI7QUFDRjtBQUVPLE1BQU1ZLDRCQUE0Qko7SUFDdkNULFlBQVlDLFVBQWtCLDRDQUE0QyxDQUFFO1FBQzFFLEtBQUssQ0FBQ0EsU0FBUztJQUNqQjtBQUNGO0FBRU8sTUFBTWEsOEJBQThCTDtJQUN6Q1QsWUFBWUMsVUFBa0IsNENB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O0lBQy9CLE9BQU8sSUFBSXBCLFNBQVNHLFNBQVNDLFFBQVE7QUFDdkM7QUFFQTs7Q0FFQyxHQUNNLFNBQVM2QixXQUFXRixLQUFjO0lBQ3ZDLE9BQU9BLGlCQUFpQi9CO0FBQzFCO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0MsdUJBQXVCSCxLQUFjO0lBQ25ELElBQUlFLFdBQVdGLFFBQVE7UUFDckIsT0FBT0EsTUFBTTVCLE9BQU87SUFDdEI7SUFDQSxJQUFJNEIsaUJBQWlCOUIsT0FBTztRQUMxQixPQUFPOEIsTUFBTTVCLE9BQU87SUFDdEI7SUFDQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3V0aWxzL2Vycm9ycy50cz84MzJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3VzdG9tIEVycm9yIENsYXNzZXNcbiAqIFByb2R1Y3Rpb24tcmVhZHkgZXJyb3IgaGFuZGxpbmcgZm9yIHRoZSBhcHBcbiAqL1xuXG4vKipcbiAqIEJhc2UgYXBwbGljYXRpb24gZXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgY29kZTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaXNPcGVyYXRpb25hbDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgY29kZTogc3RyaW5nID0gJ0FQUF9FUlJPUicsXG4gICAgc3RhdHVzQ29kZTogbnVtYmVyID0gNTAwLFxuICAgIGlzT3BlcmF0aW9uYWw6IGJvb2xlYW4gPSB0cnVlXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLmlzT3BlcmF0aW9uYWwgPSBpc09wZXJhdGlvbmFsO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBcHBFcnJvci5wcm90b3R5cGUpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG59XG5cbi8qKlxuICogQXV0aGVudGljYXRpb24gZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBBcHBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29kZTogc3RyaW5nID0gJ0FVVEhfRVJST1InKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY29kZSwgNDAxKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgPSAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnSU5WQUxJRF9DUkVERU5USUFMUycpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVc2VyQWxyZWFkeUV4aXN0c0Vycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ0EgdXNlciB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMuIFBsZWFzZSBzaWduIGluIGluc3RlYWQuJykge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdVU0VSX0FMUkVBRFlfRVhJU1RTJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVzZXJOb3RGb3VuZEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1VzZXIgbm90IGZvdW5kJykge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdVU0VSX05PVF9GT1VORCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9uRXhwaXJlZEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1Nlc3Npb24gaGFzIGV4cGlyZWQuIFBsZWFzZSBzaWduIGluIGFnYWluLicpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnU0VTU0lPTl9FWFBJUkVEJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVtYWlsTm90VmVyaWZpZWRFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZyA9ICdQbGVhc2UgdmVyaWZ5IHlvdXIgZW1haWwgYmVmb3JlIGNvbnRpbnVpbmcnKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0VNQUlMX05PVF9WRVJJRklFRCcpO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGlvbiBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGVycm9yczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZXJyb3JzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdWQUxJREFUSU9OX0VSUk9SJywgNDAwKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgfVxufVxuXG4vKipcbiAqIERhdGFiYXNlIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgRGF0YWJhc2VFcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ0RhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQnKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0RBVEFCQVNFX0VSUk9SJywgNTAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVjb3JkTm90Rm91bmRFcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1JlY29yZCBub3QgZm91bmQnKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ1JFQ09SRF9OT1RfRk9VTkQnLCA0MDQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEdXBsaWNhdGVSZWNvcmRFcnJvciBleHRlbmRzIEFwcEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ1JlY29yZCBhbHJlYWR5IGV4aXN0cycpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnRFVQTElDQVRFX1JFQ09SRCcsIDQwOSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTdG9yYWdlIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgQXBwRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgPSAnU3RvcmFnZSBvcGVyYXRpb24gZmFpbGVkJykge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdTVE9SQUdFX0VSUk9SJywgNTAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmlsZVVwbG9hZEVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nID0gJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZScpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSAnRklMRV9VUExPQURfRVJST1InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaWxlVG9vTGFyZ2VFcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1heFNpemVNQjogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKGBGaWxlIHNpemUgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiAke21heFNpemVNQn1NQmApO1xuICAgIHRoaXMuY29kZSA9ICdGSUxFX1RPT19MQVJHRSc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludmFsaWRGaWxlVHlwZUVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgY29uc3RydWN0b3IoYWxsb3dlZFR5cGVzOiBzdHJpbmdbXSA9IFsnaW1hZ2UvanBlZycsICdpbWFnZS9wbmcnLCAnaW1hZ2Uvd2VicCddKSB7XG4gICAgc3VwZXIoYEludmFsaWQgZmlsZSB0eXBlLiBBbGxvd2VkIHR5cGVzOiAke2FsbG93ZWRUeXBlcy5qb2luKCcsICcpfWApO1xuICAgIHRoaXMuY29kZSA9ICdJTlZBTElEX0ZJTEVfVFlQRSc7XG4gIH1cbn1cblxuLyoqXG4gKiBOZXR3b3JrIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgQXBwRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgPSAnTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnTkVUV09SS19FUlJPUicsIDUwMyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBTdXBhYmFzZSBlcnJvcnMgaW50byBjdXN0b20gZXJyb3JzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3I6IGFueSk6IEFwcEVycm9yIHtcbiAgY29uc3QgbWVzc2FnZSA9IGVycm9yPy5tZXNzYWdlIHx8ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJztcbiAgY29uc3QgY29kZSA9IGVycm9yPy5jb2RlIHx8ICcnO1xuXG4gIC8vIEF1dGggZXJyb3JzXG4gIGlmIChcbiAgICBtZXNzYWdlLmluY2x1ZGVzKCdVc2VyIGFscmVhZHkgcmVnaXN0ZXJlZCcpIHx8XG4gICAgbWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSB8fFxuICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgcmVnaXN0ZXJlZCcpIHx8XG4gICAgY29kZSA9PT0gJ3VzZXJfYWxyZWFkeV9leGlzdHMnIHx8XG4gICAgY29kZSA9PT0gJzIzNTA1JyAvLyBQb3N0Z3JlU1FMIHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICApIHtcbiAgICByZXR1cm4gbmV3IFVzZXJBbHJlYWR5RXhpc3RzRXJyb3IoKTtcbiAgfVxuICBpZiAobWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCBsb2dpbiBjcmVkZW50aWFscycpIHx8IGNvZGUgPT09ICdpbnZhbGlkX2NyZWRlbnRpYWxzJykge1xuICAgIHJldHVybiBuZXcgSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoKTtcbiAgfVxuICBpZiAobWVzc2FnZS5pbmNsdWRlcygnRW1haWwgbm90IGNvbmZpcm1lZCcpKSB7XG4gICAgcmV0dXJuIG5ldyBFbWFpbE5vdFZlcmlmaWVkRXJyb3IoKTtcbiAgfVxuICBpZiAobWVzc2FnZS5pbmNsdWRlcygnSldUJykgfHwgbWVzc2FnZS5pbmNsdWRlcygndG9rZW4nKSB8fCBjb2RlID09PSAnc2Vzc2lvbl9leHBpcmVkJykge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkV4cGlyZWRFcnJvcigpO1xuICB9XG4gIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdVc2VyIG5vdCBmb3VuZCcpKSB7XG4gICAgcmV0dXJuIG5ldyBVc2VyTm90Rm91bmRFcnJvcigpO1xuICB9XG5cbiAgLy8gRGF0YWJhc2UgZXJyb3JzXG4gIGlmIChjb2RlID09PSAnMjM1MDUnIHx8IG1lc3NhZ2UuaW5jbHVkZXMoJ2R1cGxpY2F0ZSBrZXknKSkge1xuICAgIHJldHVybiBuZXcgRHVwbGljYXRlUmVjb3JkRXJyb3IoKTtcbiAgfVxuICBpZiAoY29kZSA9PT0gJ1BHUlNUMTE2JyB8fCBtZXNzYWdlLmluY2x1ZGVzKCdub3QgZm91bmQnKSkge1xuICAgIHJldHVybiBuZXcgUmVjb3JkTm90Rm91bmRFcnJvcigpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBnZW5lcmljIGFwcCBlcnJvclxuICByZXR1cm4gbmV3IEFwcEVycm9yKG1lc3NhZ2UsIGNvZGUgfHwgJ1VOS05PV05fRVJST1InKTtcbn1cblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGVycm9yIGlzIGFuIEFwcEVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FwcEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXBwRXJyb3Ige1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBBcHBFcnJvcjtcbn1cblxuLyoqXG4gKiBHZXQgdXNlci1mcmllbmRseSBlcnJvciBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyRnJpZW5kbHlNZXNzYWdlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKGlzQXBwRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4uJztcbn1cblxuIl0sIm5hbWVzIjpbIkFwcEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwic3RhdHVzQ29kZSIsImlzT3BlcmF0aW9uYWwiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiQXV0aEVycm9yIiwiSW52YWxpZENyZWRlbnRpYWxzRXJyb3IiLCJVc2VyQWxyZWFkeUV4aXN0c0Vycm9yIiwiVXNlck5vdEZvdW5kRXJyb3IiLCJTZXNzaW9uRXhwaXJlZEVycm9yIiwiRW1haWxOb3RWZXJpZmllZEVycm9yIiwiVmFsaWRhdGlvbkVycm9yIiwiZXJyb3JzIiwiRGF0YWJhc2VFcnJvciIsIlJlY29yZE5vdEZvdW5kRXJyb3IiLCJEdXBsaWNhdGVSZWNvcmRFcnJvciIsIlN0b3JhZ2VFcnJvciIsIkZpbGVVcGxvYWRFcnJvciIsIkZpbGVUb29MYXJnZUVycm9yIiwibWF4U2l6ZU1CIiwiSW52YWxpZEZpbGVUeXBlRXJyb3IiLCJhbGxvd2VkVHlwZXMiLCJqb2luIiwiTmV0d29ya0Vycm9yIiwicGFyc2VTdXBhYmFzZUVycm9yIiwiZXJyb3IiLCJpbmNsdWRlcyIsImlzQXBwRXJyb3IiLCJnZXRVc2VyRnJpZW5kbHlNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../utils/errors.ts\n"));

/***/ })

}]);