"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../services/authService.ts":
/*!**********************************!*\
  !*** ../services/authService.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkEmailExists: function() { return /* binding */ checkEmailExists; },\n/* harmony export */   deleteAccount: function() { return /* binding */ deleteAccount; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   getSession: function() { return /* binding */ getSession; },\n/* harmony export */   onAuthStateChange: function() { return /* binding */ onAuthStateChange; },\n/* harmony export */   refreshSession: function() { return /* binding */ refreshSession; },\n/* harmony export */   resendVerificationEmail: function() { return /* binding */ resendVerificationEmail; },\n/* harmony export */   sendPasswordResetEmail: function() { return /* binding */ sendPasswordResetEmail; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   updatePassword: function() { return /* binding */ updatePassword; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _utils_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/validators */ \"(app-pages-browser)/../utils/validators.ts\");\n/* harmony import */ var _utils_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/errors */ \"(app-pages-browser)/../utils/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/logger */ \"(app-pages-browser)/../utils/logger.ts\");\n/**\n * Authentication Service\n * Clean, production-ready auth operations\n */ \n\n\n\n// ============================================================================\n// SIGN IN\n// ============================================================================\n/**\n * Sign in with email and password\n */ async function signIn(input) {\n    // Validate input\n    const result = _utils_validators__WEBPACK_IMPORTED_MODULE_1__.signInSchema.safeParse(input);\n    if (!result.success) {\n        const errors = {};\n        result.error.errors.forEach((err)=>{\n            const path = err.path.join(\".\");\n            if (!errors[path]) errors[path] = [];\n            errors[path].push(err.message);\n        });\n        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError(\"Invalid input\", errors);\n    }\n    const { email, password } = result.data;\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n    if (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.authLogger.signIn(email, false, error.message);\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n    // Log successful sign in with user details\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__.authLogger.signIn(email, true);\n    if (data.user) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.info(\"AUTH\", \"User signed in successfully\", {\n            userId: data.user.id,\n            email: data.user.email,\n            action: \"sign_in_success\"\n        });\n    }\n    return {\n        user: data.user,\n        session: data.session\n    };\n}\n// ============================================================================\n// SIGN UP\n// ============================================================================\n/**\n * Sign up with email and password (creates auth user only)\n * Profile data is saved separately via userService\n */ async function signUp(email, password, fullName) {\n    // Let Supabase handle email validation - it will return an error if email exists\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.signUp({\n        email,\n        password,\n        options: {\n            data: {\n                full_name: fullName\n            }\n        }\n    });\n    if (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.authLogger.signUp(email, false, undefined, error.message);\n        // Parse error will convert \"User already registered\" to UserAlreadyExistsError\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n    // Log successful sign up\n    if (data.user) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.authLogger.signUp(email, true, data.user.id);\n    }\n    // Check if email confirmation is required\n    const needsEmailVerification = !data.session && !!data.user;\n    return {\n        user: data.user,\n        session: data.session,\n        needsEmailVerification\n    };\n}\n// ============================================================================\n// CHECK EMAIL EXISTS\n// ============================================================================\n/**\n * Check if an email is already registered\n * Note: This is a best-effort check. Supabase will also validate on signup.\n */ async function checkEmailExists(email) {\n    try {\n        // Try to sign in with a dummy password - if user exists, we get a specific error\n        const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.signInWithPassword({\n            email,\n            password: \"dummy-password-check-12345\"\n        });\n        // If error is \"Invalid login credentials\", user exists\n        // If error is \"User not found\" or similar, user doesn't exist\n        if (error) {\n            if (error.message.includes(\"Invalid login credentials\") || error.message.includes(\"Invalid\")) {\n                return true;\n            }\n            // User doesn't exist\n            return false;\n        }\n        // If no error (unlikely with dummy password), user exists\n        return true;\n    } catch (error) {\n        // If check fails, let Supabase handle the validation on signup\n        return false;\n    }\n}\n// ============================================================================\n// SIGN OUT\n// ============================================================================\n/**\n * Sign out current user\n */ async function signOut() {\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.signOut();\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n}\n// ============================================================================\n// SESSION MANAGEMENT\n// ============================================================================\n/**\n * Get current session\n */ async function getSession() {\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getSession();\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n    return data.session;\n}\n/**\n * Get current authenticated user\n */ async function getCurrentUser() {\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (error) {\n        // Don't throw for \"not authenticated\" errors\n        if (error.message.includes(\"Auth session missing\")) {\n            return null;\n        }\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n    return data.user;\n}\n/**\n * Refresh the current session\n */ async function refreshSession() {\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.refreshSession();\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n    return data.session;\n}\n// ============================================================================\n// PASSWORD RESET\n// ============================================================================\n/**\n * Send password reset email\n */ async function sendPasswordResetEmail(email) {\n    // Validate email\n    const result = _utils_validators__WEBPACK_IMPORTED_MODULE_1__.forgotPasswordSchema.safeParse({\n        email\n    });\n    if (!result.success) {\n        throw new _utils_errors__WEBPACK_IMPORTED_MODULE_2__.ValidationError(\"Invalid email address\");\n    }\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.resetPasswordForEmail(email, {\n        redirectTo: \"taalmeet://reset-password\"\n    });\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n}\n/**\n * Update password (for authenticated users)\n */ async function updatePassword(newPassword) {\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.updateUser({\n        password: newPassword\n    });\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n}\n// ============================================================================\n// AUTH STATE LISTENER\n// ============================================================================\n/**\n * Subscribe to auth state changes\n */ function onAuthStateChange(callback) {\n    const { data } = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.onAuthStateChange((event, session)=>{\n        callback(event, session);\n    });\n    return data.subscription;\n}\n// ============================================================================\n// EMAIL VERIFICATION\n// ============================================================================\n/**\n * Resend verification email\n */ async function resendVerificationEmail(email) {\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.resend({\n        type: \"signup\",\n        email\n    });\n    if (error) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(error);\n    }\n}\n// ============================================================================\n// ACCOUNT DELETION\n// ============================================================================\n/**\n * Delete user account and all associated data\n * This will cascade delete all user data due to ON DELETE CASCADE constraints\n * \n * Process:\n * 1. Delete all database records (via RPC function)\n * 2. Delete auth user (requires admin API or server-side function)\n * 3. Sign out\n */ async function deleteAccount(userId) {\n    // Step 1: Delete all database records (profiles, messages, connections, etc.)\n    // This uses the delete_user_account function which handles cascade deletion\n    const { error: dbError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"delete_user_account\", {\n        user_id: userId\n    });\n    if (dbError) {\n        throw (0,_utils_errors__WEBPACK_IMPORTED_MODULE_2__.parseSupabaseError)(dbError);\n    }\n    // Step 2: Delete auth user\n    // Note: Client-side code cannot delete auth users directly (requires admin API).\n    // The database cleanup is done above. For production, you should:\n    // 1. Create a server-side endpoint that uses service role key to delete auth user\n    // 2. Call that endpoint here, or\n    // 3. Use Supabase Edge Functions to handle auth deletion\n    // \n    // For now, database cleanup is complete. The auth user deletion should be\n    // handled by a server-side function or Edge Function.\n    // Step 3: Sign out\n    await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.signOut();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zZXJ2aWNlcy9hdXRoU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRXlDO0FBT2Q7QUFPSjtBQUM0QjtBQWdCcEQsK0VBQStFO0FBQy9FLFVBQVU7QUFDViwrRUFBK0U7QUFFL0U7O0NBRUMsR0FDTSxlQUFlTyxPQUFPQyxLQUFrQjtJQUM3QyxpQkFBaUI7SUFDakIsTUFBTUMsU0FBU1IsMkRBQVlBLENBQUNTLFNBQVMsQ0FBQ0Y7SUFDdEMsSUFBSSxDQUFDQyxPQUFPRSxPQUFPLEVBQUU7UUFDbkIsTUFBTUMsU0FBbUMsQ0FBQztRQUMxQ0gsT0FBT0ksS0FBSyxDQUFDRCxNQUFNLENBQUNFLE9BQU8sQ0FBQyxDQUFDQztZQUMzQixNQUFNQyxPQUFPRCxJQUFJQyxJQUFJLENBQUNDLElBQUksQ0FBQztZQUMzQixJQUFJLENBQUNMLE1BQU0sQ0FBQ0ksS0FBSyxFQUFFSixNQUFNLENBQUNJLEtBQUssR0FBRyxFQUFFO1lBQ3BDSixNQUFNLENBQUNJLEtBQUssQ0FBQ0UsSUFBSSxDQUFDSCxJQUFJSSxPQUFPO1FBQy9CO1FBQ0EsTUFBTSxJQUFJZiwwREFBZUEsQ0FBQyxpQkFBaUJRO0lBQzdDO0lBRUEsTUFBTSxFQUFFUSxLQUFLLEVBQUVDLFFBQVEsRUFBRSxHQUFHWixPQUFPYSxJQUFJO0lBRXZDLE1BQU0sRUFBRUEsSUFBSSxFQUFFVCxLQUFLLEVBQUUsR0FBRyxNQUFNYixtREFBUUEsQ0FBQ3VCLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7UUFDN0RKO1FBQ0FDO0lBQ0Y7SUFFQSxJQUFJUixPQUFPO1FBQ1RSLHFEQUFVQSxDQUFDRSxNQUFNLENBQUNhLE9BQU8sT0FBT1AsTUFBTU0sT0FBTztRQUM3QyxNQUFNaEIsaUVBQWtCQSxDQUFDVTtJQUMzQjtJQUVBLDJDQUEyQztJQUMzQ1IscURBQVVBLENBQUNFLE1BQU0sQ0FBQ2EsT0FBTztJQUV6QixJQUFJRSxLQUFL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Y2UudHM/ZDhiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1dGhlbnRpY2F0aW9uIFNlcnZpY2VcbiAqIENsZWFuLCBwcm9kdWN0aW9uLXJlYWR5IGF1dGggb3BlcmF0aW9uc1xuICovXG5cbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuaW1wb3J0IHtcbiAgc2lnbkluU2NoZW1hLFxuICBzaWduVXBTY2hlbWEsXG4gIGZvcmdvdFBhc3N3b3JkU2NoZW1hLFxuICB0eXBlIFNpZ25JbklucHV0LFxuICB0eXBlIEZ1bGxTaWdudXBJbnB1dCxcbn0gZnJvbSAnQC91dGlscy92YWxpZGF0b3JzJztcbmltcG9ydCB7XG4gIEF1dGhFcnJvcixcbiAgSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsXG4gIFVzZXJBbHJlYWR5RXhpc3RzRXJyb3IsXG4gIHBhcnNlU3VwYWJhc2VFcnJvcixcbiAgVmFsaWRhdGlvbkVycm9yLFxufSBmcm9tICdAL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgeyBhdXRoTG9nZ2VyLCBsb2dnZXIgfSBmcm9tICdAL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IFVzZXIgYXMgU3VwYWJhc2VVc2VyLCBTZXNzaW9uIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVFlQRVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoUmVzcG9uc2Uge1xuICB1c2VyOiBTdXBhYmFzZVVzZXIgfCBudWxsO1xuICBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduVXBSZXNwb25zZSBleHRlbmRzIEF1dGhSZXNwb25zZSB7XG4gIG5lZWRzRW1haWxWZXJpZmljYXRpb246IGJvb2xlYW47XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNJR04gSU5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBTaWduIGluIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW4oaW5wdXQ6IFNpZ25JbklucHV0KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgLy8gVmFsaWRhdGUgaW5wdXRcbiAgY29uc3QgcmVzdWx0ID0gc2lnbkluU2NoZW1hLnNhZmVQYXJzZShpbnB1dCk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICBjb25zdCBlcnJvcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIHJlc3VsdC5lcnJvci5lcnJvcnMuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zdCBwYXRoID0gZXJyLnBhdGguam9pbignLicpO1xuICAgICAgaWYgKCFlcnJvcnNbcGF0aF0pIGVycm9yc1twYXRoXSA9IFtdO1xuICAgICAgZXJyb3JzW3BhdGhdLnB1c2goZXJyLm1lc3NhZ2UpO1xuICAgIH0pO1xuICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0ludmFsaWQgaW5wdXQnLCBlcnJvcnMpO1xuICB9XG5cbiAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQgfSA9IHJlc3VsdC5kYXRhO1xuXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZCxcbiAgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgYXV0aExvZ2dlci5zaWduSW4oZW1haWwsIGZhbHNlLCBlcnJvci5tZXNzYWdlKTtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgLy8gTG9nIHN1Y2Nlc3NmdWwgc2lnbiBpbiB3aXRoIHVzZXIgZGV0YWlsc1xuICBhdXRoTG9nZ2VyLnNpZ25JbihlbWFpbCwgdHJ1ZSk7XG4gIFxuICBpZiAoZGF0YS51c2VyKSB7XG4gICAgbG9nZ2VyLmluZm8oJ0FVVEgnLCAnVXNlciBzaWduZWQgaW4gc3VjY2Vzc2Z1bGx5Jywge1xuICAgICAgdXNlcklkOiBkYXRhLnVzZXIuaWQsXG4gICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxuICAgICAgYWN0aW9uOiAnc2lnbl9pbl9zdWNjZXNzJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXNlcjogZGF0YS51c2VyLFxuICAgIHNlc3Npb246IGRhdGEuc2Vzc2lvbixcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU0lHTiBVUFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFNpZ24gdXAgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgKGNyZWF0ZXMgYXV0aCB1c2VyIG9ubHkpXG4gKiBQcm9maWxlIGRhdGEgaXMgc2F2ZWQgc2VwYXJhdGVseSB2aWEgdXNlclNlcnZpY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25VcChcbiAgZW1haWw6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZ1xuKTogUHJvbWlzZTxTaWduVXBSZXNwb25zZT4ge1xuICAvLyBMZXQgU3VwYWJhc2UgaGFuZGxlIGVtYWlsIHZhbGlkYXRpb24gLSBpdCB3aWxsIHJldHVybiBhbiBlcnJvciBpZiBlbWFpbCBleGlzdHNcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduVXAoe1xuICAgIGVtYWlsLFxuICAgIHBhc3N3b3JkLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZnVsbF9uYW1lOiBmdWxsTmFtZSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgYXV0aExvZ2dlci5zaWduVXAoZW1haWwsIGZhbHNlLCB1bmRlZmluZWQsIGVycm9yLm1lc3NhZ2UpO1xuICAgIC8vIFBhcnNlIGVycm9yIHdpbGwgY29udmVydCBcIlVzZXIgYWxyZWFkeSByZWdpc3RlcmVkXCIgdG8gVXNlckFscmVhZHlFeGlzdHNFcnJvclxuICAgIHRocm93IHBhcnNlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gIH1cblxuICAvLyBMb2cgc3VjY2Vzc2Z1bCBzaWduIHVwXG4gIGlmIChkYXRhLnVzZXIpIHtcbiAgICBhdXRoTG9nZ2VyLnNpZ25VcChlbWFpbCwgdHJ1ZSwgZGF0YS51c2VyLmlkKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGVtYWlsIGNvbmZpcm1hdGlvbiBpcyByZXF1aXJlZFxuICBjb25zdCBuZWVkc0VtYWlsVmVyaWZpY2F0aW9uID0gIWRhdGEuc2Vzc2lvbiAmJiAhIWRhdGEudXNlcjtcblxuICByZXR1cm4ge1xuICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICBzZXNzaW9uOiBkYXRhLnNlc3Npb24sXG4gICAgbmVlZHNFbWFpbFZlcmlmaWNhdGlvbixcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ0hFQ0sgRU1BSUwgRVhJU1RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZW1haWwgaXMgYWxyZWFkeSByZWdpc3RlcmVkXG4gKiBOb3RlOiBUaGlzIGlzIGEgYmVzdC1lZmZvcnQgY2hlY2suIFN1cGFiYXNlIHdpbGwgYWxzbyB2YWxpZGF0ZSBvbiBzaWdudXAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0VtYWlsRXhpc3RzKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICAvLyBUcnkgdG8gc2lnbiBpbiB3aXRoIGEgZHVtbXkgcGFzc3dvcmQgLSBpZiB1c2VyIGV4aXN0cywgd2UgZ2V0IGEgc3BlY2lmaWMgZXJyb3JcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkOiAnZHVtbXktcGFzc3dvcmQtY2hlY2stMTIzNDUnLFxuICAgIH0pO1xuXG4gICAgLy8gSWYgZXJyb3IgaXMgXCJJbnZhbGlkIGxvZ2luIGNyZWRlbnRpYWxzXCIsIHVzZXIgZXhpc3RzXG4gICAgLy8gSWYgZXJyb3IgaXMgXCJVc2VyIG5vdCBmb3VuZFwiIG9yIHNpbWlsYXIsIHVzZXIgZG9lc24ndCBleGlzdFxuICAgIGlmIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdJbnZhbGlkJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBVc2VyIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiBubyBlcnJvciAodW5saWtlbHkgd2l0aCBkdW1teSBwYXNzd29yZCksIHVzZXIgZXhpc3RzXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgY2hlY2sgZmFpbHMsIGxldCBTdXBhYmFzZSBoYW5kbGUgdGhlIHZhbGlkYXRpb24gb24gc2lnbnVwXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNJR04gT1VUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogU2lnbiBvdXQgY3VycmVudCB1c2VyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNFU1NJT04gTUFOQUdFTUVOVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBjdXJyZW50IHNlc3Npb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlc3Npb24oKTogUHJvbWlzZTxTZXNzaW9uIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGEuc2Vzc2lvbjtcbn1cblxuLyoqXG4gKiBHZXQgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRVc2VyKCk6IFByb21pc2U8U3VwYWJhc2VVc2VyIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICAvLyBEb24ndCB0aHJvdyBmb3IgXCJub3QgYXV0aGVudGljYXRlZFwiIGVycm9yc1xuICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdBdXRoIHNlc3Npb24gbWlzc2luZycpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhLnVzZXI7XG59XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgY3VycmVudCBzZXNzaW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoU2Vzc2lvbigpOiBQcm9taXNlPFNlc3Npb24gfCBudWxsPiB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVmcmVzaFNlc3Npb24oKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGEuc2Vzc2lvbjtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUEFTU1dPUkQgUkVTRVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBTZW5kIHBhc3N3b3JkIHJlc2V0IGVtYWlsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gVmFsaWRhdGUgZW1haWxcbiAgY29uc3QgcmVzdWx0ID0gZm9yZ290UGFzc3dvcmRTY2hlbWEuc2FmZVBhcnNlKHsgZW1haWwgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKTtcbiAgfVxuXG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZXRQYXNzd29yZEZvckVtYWlsKGVtYWlsLCB7XG4gICAgcmVkaXJlY3RUbzogJ3RhYWxtZWV0Oi8vcmVzZXQtcGFzc3dvcmQnLFxuICB9KTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBwYXJzZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHBhc3N3b3JkIChmb3IgYXV0aGVudGljYXRlZCB1c2VycylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhc3N3b3JkKG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC51cGRhdGVVc2VyKHtcbiAgICBwYXNzd29yZDogbmV3UGFzc3dvcmQsXG4gIH0pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IHBhcnNlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQVVUSCBTVEFURSBMSVNURU5FUlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFN1YnNjcmliZSB0byBhdXRoIHN0YXRlIGNoYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlKFxuICBjYWxsYmFjazogKGV2ZW50OiBzdHJpbmcsIHNlc3Npb246IFNlc3Npb24gfCBudWxsKSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChldmVudCwgc2Vzc2lvbikgPT4ge1xuICAgIGNhbGxiYWNrKGV2ZW50LCBzZXNzaW9uKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGEuc3Vic2NyaXB0aW9uO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFTUFJTCBWRVJJRklDQVRJT05cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBSZXNlbmQgdmVyaWZpY2F0aW9uIGVtYWlsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNlbmRWZXJpZmljYXRpb25FbWFpbChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGgucmVzZW5kKHtcbiAgICB0eXBlOiAnc2lnbnVwJyxcbiAgICBlbWFpbCxcbiAgfSk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgcGFyc2VTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBQ0NPVU5UIERFTEVUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRGVsZXRlIHVzZXIgYWNjb3VudCBhbmQgYWxsIGFzc29jaWF0ZWQgZGF0YVxuICogVGhpcyB3aWxsIGNhc2NhZGUgZGVsZXRlIGFsbCB1c2VyIGRhdGEgZHVlIHRvIE9OIERFTEVURSBDQVNDQURFIGNvbnN0cmFpbnRzXG4gKiBcbiAqIFByb2Nlc3M6XG4gKiAxLiBEZWxldGUgYWxsIGRhdGFiYXNlIHJlY29yZHMgKHZpYSBSUEMgZnVuY3Rpb24pXG4gKiAyLiBEZWxldGUgYXV0aCB1c2VyIChyZXF1aXJlcyBhZG1pbiBBUEkgb3Igc2VydmVyLXNpZGUgZnVuY3Rpb24pXG4gKiAzLiBTaWduIG91dFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWNjb3VudCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBTdGVwIDE6IERlbGV0ZSBhbGwgZGF0YWJhc2UgcmVjb3JkcyAocHJvZmlsZXMsIG1lc3NhZ2VzLCBjb25uZWN0aW9ucywgZXRjLilcbiAgLy8gVGhpcyB1c2VzIHRoZSBkZWxldGVfdXNlcl9hY2NvdW50IGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgY2FzY2FkZSBkZWxldGlvblxuICBjb25zdCB7IGVycm9yOiBkYkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2RlbGV0ZV91c2VyX2FjY291bnQnLCB7XG4gICAgdXNlcl9pZDogdXNlcklkLFxuICB9KTtcblxuICBpZiAoZGJFcnJvcikge1xuICAgIHRocm93IHBhcnNlU3VwYWJhc2VFcnJvcihkYkVycm9yKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMjogRGVsZXRlIGF1dGggdXNlclxuICAvLyBOb3RlOiBDbGllbnQtc2lkZSBjb2RlIGNhbm5vdCBkZWxldGUgYXV0aCB1c2VycyBkaXJlY3RseSAocmVxdWlyZXMgYWRtaW4gQVBJKS5cbiAgLy8gVGhlIGRhdGFiYXNlIGNsZWFudXAgaXMgZG9uZSBhYm92ZS4gRm9yIHByb2R1Y3Rpb24sIHlvdSBzaG91bGQ6XG4gIC8vIDEuIENyZWF0ZSBhIHNlcnZlci1zaWRlIGVuZHBvaW50IHRoYXQgdXNlcyBzZXJ2aWNlIHJvbGUga2V5IHRvIGRlbGV0ZSBhdXRoIHVzZXJcbiAgLy8gMi4gQ2FsbCB0aGF0IGVuZHBvaW50IGhlcmUsIG9yXG4gIC8vIDMuIFVzZSBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9ucyB0byBoYW5kbGUgYXV0aCBkZWxldGlvblxuICAvLyBcbiAgLy8gRm9yIG5vdywgZGF0YWJhc2UgY2xlYW51cCBpcyBjb21wbGV0ZS4gVGhlIGF1dGggdXNlciBkZWxldGlvbiBzaG91bGQgYmVcbiAgLy8gaGFuZGxlZCBieSBhIHNlcnZlci1zaWRlIGZ1bmN0aW9uIG9yIEVkZ2UgRnVuY3Rpb24uXG5cbiAgLy8gU3RlcCAzOiBTaWduIG91dFxuICBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25PdXQoKTtcbn1cblxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwic2lnbkluU2NoZW1hIiwiZm9yZ290UGFzc3dvcmRTY2hlbWEiLCJwYXJzZVN1cGFiYXNlRXJyb3IiLCJWYWxpZGF0aW9uRXJyb3IiLCJhdXRoTG9nZ2VyIiwibG9nZ2VyIiwic2lnbkluIiwiaW5wdXQiLCJyZXN1bHQiLCJzYWZlUGFyc2UiLCJzdWNjZXNzIiwiZXJyb3JzIiwiZXJyb3IiLCJmb3JFYWNoIiwiZXJyIiwicGF0aCIsImpvaW4iLCJwdXNoIiwibWVzc2FnZSIsImVtYWlsIiwicGFzc3dvcmQiLCJkYXRhIiwiYXV0aCIsInNpZ25JbldpdGhQYXNzd29yZCIsInVzZXIiLCJpbmZvIiwidXNlcklkIiwiaWQiLCJhY3Rpb24iLCJzZXNzaW9uIiwic2lnblVwIiwiZnVsbE5hbWUiLCJvcHRpb25zIiwiZnVsbF9uYW1lIiwidW5kZWZpbmVkIiwibmVlZHNFbWFpbFZlcmlmaWNhdGlvbiIsImNoZWNrRW1haWxFeGlzdHMiLCJpbmNsdWRlcyIsInNpZ25PdXQiLCJnZXRTZXNzaW9uIiwiZ2V0Q3VycmVudFVzZXIiLCJnZXRVc2VyIiwicmVmcmVzaFNlc3Npb24iLCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwicmVkaXJlY3RUbyIsInVwZGF0ZVBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJ1cGRhdGVVc2VyIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJjYWxsYmFjayIsImV2ZW50Iiwic3Vic2NyaXB0aW9uIiwicmVzZW5kVmVyaWZpY2F0aW9uRW1haWwiLCJyZXNlbmQiLCJ0eXBlIiwiZGVsZXRlQWNjb3VudCIsImRiRXJyb3IiLCJycGMiLCJ1c2VyX2lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../services/authService.ts\n"));

/***/ })

});